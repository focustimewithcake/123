// netlify/functions/ai-mindmap-bot.js
const MindMapAIBot = class {
  constructor() {
    this.vietnameseStopWords = new Set([
      'v√†', 'c·ªßa', 'l√†', 'c√≥', 'ƒë∆∞·ª£c', 'trong', 'ngo√†i', 'tr√™n', 'd∆∞·ªõi', 'v·ªõi',
      'nh∆∞', 'theo', 't·ª´', 'v·ªÅ', 'sau', 'tr∆∞·ªõc', 'khi', 'n·∫øu', 'th√¨', 'm√†',
      'n√†y', 'ƒë√≥', 'kia', 'ai', 'g√¨', 'n√†o', 'sao', 'v√¨', 't·∫°i', 'do', 'b·ªüi',
      'cho', 'ƒë·∫øn', 'l√™n', 'xu·ªëng', 'ra', 'v√†o', '·ªü', 't·∫°i', 'b·∫±ng', 'ƒëang',
      's·∫Ω', 'ƒë√£', 'r·∫•t', 'qu√°', 'c≈©ng', 'v·∫´n', 'c·ª©', 'ch·ªâ', 'm·ªói', 't·ª´ng',
      'm·ªôt', 'hai', 'ba', 'b·ªën', 'nƒÉm', 'm·∫•y', 'nhi·ªÅu', '√≠t', 'c√°c', 'nh·ªØng',
      'm·ªçi', 'to√†n', 'c·∫£', 'ch√≠nh', 'ngay', 'lu√¥n', 'v·ª´a', 'm·ªõi', 'ƒë·ªÅu', 'ch∆∞a'
    ]);
  }

  generateMindMap(text, style = 'balanced', complexity = 'medium') {
    console.log('ü§ñ AI Bot ƒëang ph√¢n t√≠ch vƒÉn b·∫£n...');
    
    const cleanedText = this.cleanText(text);
    const analysis = this.analyzeText(cleanedText);
    const mindmap = this.createMindMapStructure(analysis, style, complexity);
    
    return mindmap;
  }

  cleanText(text) {
    if (!text) return '';
    return text
      .replace(/[^\w\s√Ä√Å√Ç√É√à√â√ä√å√ç√í√ì√î√ï√ô√ö√ù√†√°√¢√£√®√©√™√¨√≠√≤√≥√¥√µ√π√∫√ΩƒÇƒÉƒêƒëƒ®ƒ©≈®≈©∆†∆°∆Ø∆∞·∫†-·ªπ]/gu, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  analyzeText(text) {
    const sentences = this.splitSentences(text);
    const words = this.extractWords(text);
    const wordFreq = this.calculateWordFrequency(words);
    const keywords = this.extractKeywords(wordFreq);
    const topics = this.extractMainTopics(sentences, keywords);
    
    return {
      sentences,
      words,
      wordFreq,
      keywords,
      topics,
      totalSentences: sentences.length,
      totalWords: words.length
    };
  }

  splitSentences(text) {
    if (!text) return [];
    return text.split(/[.!?]+/)
      .map(s => s.trim())
      .filter(s => s.length > 10 && s.length < 200);
  }

  extractWords(text) {
    if (!text) return [];
    return text
      .toLowerCase()
      .split(/\s+/)
      .filter(word => 
        word.length > 2 && 
        !this.vietnameseStopWords.has(word) &&
        !/\d/.test(word)
      );
  }

  calculateWordFrequency(words) {
    const freq = {};
    words.forEach(word => {
      freq[word] = (freq[word] || 0) + 1;
    });
    return freq;
  }

  extractKeywords(wordFreq) {
    const totalWords = Object.values(wordFreq).reduce((a, b) => a + b, 0);
    if (totalWords === 0) return [];
    
    return Object.entries(wordFreq)
      .map(([word, count]) => ({
        word,
        frequency: count,
        score: count / totalWords
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 10)
      .map(item => item.word);
  }

  // PH∆Ø∆†NG PH√ÅP M·ªöI: Tr√≠ch xu·∫•t ch·ªß ƒë·ªÅ ch√≠nh t·ª´ c√¢u
  extractMainTopics(sentences, keywords) {
    const topics = [];
    
    // T√¨m c√°c c√¢u ch·ª©a t·ª´ kh√≥a quan tr·ªçng
    keywords.forEach(keyword => {
      const relatedSentences = sentences.filter(sentence =>
        sentence.toLowerCase().includes(keyword)
      ).slice(0, 2);
      
      if (relatedSentences.length > 0) {
        topics.push({
          keyword: keyword,
          sentences: relatedSentences
        });
      }
    });
    
    return topics.slice(0, 6); // Gi·ªõi h·∫°n 6 ch·ªß ƒë·ªÅ
  }

  createMindMapStructure(analysis, style, complexity) {
    const centralTopic = this.determineCentralTopic(analysis);
    const branchCount = this.getBranchCount(complexity);
    const mainBranches = this.createMainBranches(analysis, branchCount, style);
    
    return {
      centralTopic,
      mainBranches,
      analysis: {
        totalSentences: analysis.totalSentences,
        totalWords: analysis.totalWords,
        keywords: analysis.keywords.slice(0, 5),
        confidence: this.calculateConfidence(analysis)
      },
      metadata: {
        generatedBy: "AI Mind Map Bot ü§ñ",
        style: style,
        complexity: complexity,
        timestamp: new Date().toISOString(),
        version: "FREE 2.0"
      }
    };
  }

  determineCentralTopic(analysis) {
    if (!analysis.sentences || analysis.sentences.length === 0) {
      return "Ch·ªß ƒë·ªÅ ch√≠nh";
    }
    
    // T√¨m c√¢u ƒë·∫ßu ti√™n c√≥ √Ω nghƒ©a l√†m ch·ªß ƒë·ªÅ trung t√¢m
    let centralTopic = analysis.sentences[0];
    
    // C·ªë g·∫Øng t√¨m c√¢u t·ªët h∆°n n·∫øu c√¢u ƒë·∫ßu qu√° ng·∫Øn
    if (centralTopic.length < 20) {
      const longerSentence = analysis.sentences.find(s => s.length >= 20);
      if (longerSentence) centralTopic = longerSentence;
    }
    
    // Gi·ªõi h·∫°n ƒë·ªô d√†i
    if (centralTopic.length > 50) {
      centralTopic = centralTopic.substring(0, 50) + '...';
    }
    
    return centralTopic;
  }

  getBranchCount(complexity) {
    const counts = {
      'simple': 2,
      'medium': 3,
      'detailed': 4,
      'comprehensive': 5
    };
    return counts[complexity] || 3;
  }

  createMainBranches(analysis, branchCount, style) {
    const branches = [];
    const usedKeywords = new Set();
    
    // T·∫°o nh√°nh t·ª´ c√°c ch·ªß ƒë·ªÅ ch√≠nh
    if (analysis.topics && analysis.topics.length > 0) {
      analysis.topics.slice(0, branchCount).forEach((topic, index) => {
        if (usedKeywords.has(topic.keyword)) return;
        
        const branchTitle = this.createBranchTitle(topic.keyword, style, index);
        const subTopics = this.createSubTopics(topic.sentences, style);
        
        branches.push({
          title: branchTitle,
          subTopics: subTopics.slice(0, 3) // Gi·ªõi h·∫°n 3 subtopic m·ªói nh√°nh
        });
        
        usedKeywords.add(topic.keyword);
      });
    }
    
    // Th√™m nh√°nh m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng ƒë·ªß
    const styleTemplates = this.getStyleTemplates(style);
    while (branches.length < branchCount) {
      const defaultIndex = branches.length;
      const defaultBranch = styleTemplates[defaultIndex] || styleTemplates[0];
      branches.push({
        title: defaultBranch.title,
        subTopics: defaultBranch.subTopics.slice(0, 3)
      });
    }
    
    return branches;
  }

  getStyleTemplates(style) {
    const templates = {
      'academic': [
        { 
          title: "Kh√°i ni·ªám c·ªët l√µi", 
          subTopics: ["ƒê·ªãnh nghƒ©a ch√≠nh", "ƒê·∫∑c ƒëi·ªÉm n·ªïi b·∫≠t", "Nguy√™n l√Ω ho·∫°t ƒë·ªông"] 
        },
        { 
          title: "Ph√¢n t√≠ch h·ªçc thu·∫≠t", 
          subTopics: ["L√Ω thuy·∫øt li√™n quan", "Nghi√™n c·ª©u ƒëi·ªÉn h√¨nh", "Ph∆∞∆°ng ph√°p lu·∫≠n"] 
        },
        { 
          title: "·ª®ng d·ª•ng th·ª±c ti·ªÖn", 
          subTopics: ["Case study", "B√†i h·ªçc kinh nghi·ªám", "H∆∞·ªõng ph√°t tri·ªÉn"] 
        }
      ],
      'creative': [
        { 
          title: "√ù t∆∞·ªüng s√°ng t·∫°o", 
          subTopics: ["G√≥c nh√¨n m·ªõi", "Gi·∫£i ph√°p ƒë·ªôt ph√°", "T∆∞ duy ƒëa chi·ªÅu"] 
        },
        { 
          title: "·ª®ng d·ª•ng th·ª±c t·∫ø", 
          subTopics: ["T√¨nh hu·ªëng s·ª≠ d·ª•ng", "L·ª£i √≠ch c·ª• th·ªÉ", "K·∫øt qu·∫£ mong ƒë·ª£i"] 
        },
        { 
          title: "Ph√°t tri·ªÉn √Ω t∆∞·ªüng", 
          subTopics: ["C√°c b∆∞·ªõc th·ª±c hi·ªán", "Ngu·ªìn l·ª±c c·∫ßn thi·∫øt", "ƒêo l∆∞·ªùng k·∫øt qu·∫£"] 
        }
      ],
      'business': [
        { 
          title: "Chi·∫øn l∆∞·ª£c kinh doanh", 
          subTopics: ["M·ª•c ti√™u chi·∫øn l∆∞·ª£c", "K·∫ø ho·∫°ch h√†nh ƒë·ªông", "Ph√¢n t√≠ch SWOT"] 
        },
        { 
          title: "Tri·ªÉn khai th·ª±c t·∫ø", 
          subTopics: ["C√°c b∆∞·ªõc th·ª±c hi·ªán", "Ngu·ªìn l·ª±c c·∫ßn c√≥", "L·ªô tr√¨nh th·ªùi gian"] 
        },
        { 
          title: "ƒêo l∆∞·ªùng k·∫øt qu·∫£", 
          subTopics: ["Ch·ªâ s·ªë KPI", "ƒê√°nh gi√° hi·ªáu qu·∫£", "ƒêi·ªÅu ch·ªânh chi·∫øn l∆∞·ª£c"] 
        }
      ],
      'balanced': [
        { 
          title: "Ph√¢n t√≠ch ch√≠nh", 
          subTopics: ["Th√¥ng tin c·ªët l√µi", "D·ªØ li·ªáu quan tr·ªçng", "K·∫øt lu·∫≠n ch√≠nh"] 
        },
        { 
          title: "Chi ti·∫øt b·ªï sung", 
          subTopics: ["Th√¥ng tin m·ªü r·ªông", "V√≠ d·ª• minh h·ªça", "D·ªØ li·ªáu h·ªó tr·ª£"] 
        },
        { 
          title: "·ª®ng d·ª•ng th·ª±c t·∫ø", 
          subTopics: ["T√¨nh hu·ªëng √°p d·ª•ng", "L·ª£i √≠ch th·ª±c t·∫ø", "H∆∞·ªõng d·∫´n th·ª±c hi·ªán"] 
        }
      ]
    };
    
    return templates[style] || templates.balanced;
  }

  createBranchTitle(keyword, style, index) {
    const prefixes = {
      'academic': ['Ph√¢n t√≠ch', 'Nghi√™n c·ª©u', 'Kh√°i ni·ªám', 'L√Ω thuy·∫øt'],
      'creative': ['√ù t∆∞·ªüng', 'Gi·∫£i ph√°p', 'Ph√°t tri·ªÉn', 'S√°ng t·∫°o'],
      'business': ['Chi·∫øn l∆∞·ª£c', 'K·∫ø ho·∫°ch', 'Gi·∫£i ph√°p', 'Tri·ªÉn khai'],
      'balanced': ['Kh√≠a c·∫°nh', 'G√≥c nh√¨n', 'Ph∆∞∆°ng di·ªán', '·ª®ng d·ª•ng']
    };
    
    const prefixList = prefixes[style] || prefixes.balanced;
    const prefix = prefixList[index % prefixList.length];
    
    return `${prefix} ${this.capitalizeFirst(keyword)}`;
  }

  createSubTopics(sentences, style) {
    if (!sentences || sentences.length === 0) {
      return this.getDefaultSubTopics(style);
    }
    
    return sentences
      .map(sentence => {
        // L√†m s·∫°ch v√† gi·ªõi h·∫°n ƒë·ªô d√†i c√¢u
        let cleanSentence = sentence.trim();
        if (cleanSentence.length > 60) {
          cleanSentence = cleanSentence.substring(0, 60) + '...';
        }
        
        return cleanSentence;
      })
      .filter(sentence => sentence.length > 10); // Ch·ªâ l·∫•y c√¢u c√≥ √Ω nghƒ©a
  }

  getDefaultSubTopics(style) {
    const defaults = {
      'academic': ["Th√¥ng tin h·ªçc thu·∫≠t", "D·ªØ li·ªáu nghi√™n c·ª©u", "K·∫øt qu·∫£ ph√¢n t√≠ch"],
      'creative': ["Chi ti·∫øt s√°ng t·∫°o", "·ª®ng d·ª•ng th·ª±c t·∫ø", "Ph√°t tri·ªÉn √Ω t∆∞·ªüng"],
      'business': ["Th√¥ng tin kinh doanh", "Chi·∫øn l∆∞·ª£c ph√°t tri·ªÉn", "K·∫øt qu·∫£ d·ª± ki·∫øn"],
      'balanced': ["Th√¥ng tin chi ti·∫øt", "V√≠ d·ª• minh h·ªça", "·ª®ng d·ª•ng th·ª±c t·∫ø"]
    };
    
    return defaults[style] || defaults.balanced;
  }

  calculateConfidence(analysis) {
    if (!analysis) return 0.5;
    
    const sentenceCount = analysis.totalSentences || 0;
    const wordCount = analysis.totalWords || 0;
    const keywordCount = (analysis.keywords && analysis.keywords.length) || 0;
    
    let confidence = 0;
    
    if (sentenceCount >= 3) confidence += 0.3;
    if (sentenceCount >= 5) confidence += 0.2;
    if (wordCount >= 50) confidence += 0.3;
    if (keywordCount >= 3) confidence += 0.2;
    
    return Math.min(confidence, 0.95);
  }

  capitalizeFirst(word) {
    if (!word) return '';
    return word.charAt(0).toUpperCase() + word.slice(1);
  }
};

// Export function ch√≠nh
exports.handler = async (event) => {
  console.log('=== FREE AI MIND MAP BOT STARTED ===');
  
  // CORS headers
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Allow-Methods': 'POST, OPTIONS, GET',
    'Content-Type': 'application/json'
  };

  // Handle preflight OPTIONS request
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: ''
    };
  }

  // Only allow POST
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: 'Method Not Allowed' })
    };
  }

  try {
    console.log('Parsing request body...');
    let parsedBody;
    try {
      parsedBody = JSON.parse(event.body);
      console.log('Body parsed successfully');
    } catch (parseError) {
      console.error('JSON parse error:', parseError);
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: 'Invalid JSON in request body' })
      };
    }

    const { text, style = 'balanced', complexity = 'medium' } = parsedBody;

    if (!text || text.trim().length === 0) {
      console.log('Empty text received');
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: 'Text parameter is required' })
      };
    }

    // Gi·ªõi h·∫°n 1500 ch·ªØ
    const processedText = text.length > 1500 ? text.substring(0, 1500) : text;
    
    console.log('ü§ñ FREE AI Bot processing text length:', processedText.length);
    
    // Kh·ªüi t·∫°o v√† ch·∫°y AI Bot
    const aiBot = new MindMapAIBot();
    const mindmapData = aiBot.generateMindMap(processedText, style, complexity);
    
    console.log('‚úÖ FREE AI Bot completed successfully');
    console.log('Generated mind map structure:', {
      centralTopic: mindmapData.centralTopic,
      branchCount: mindmapData.mainBranches.length,
      analysis: mindmapData.analysis
    });
    
    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(mindmapData)
    };

  } catch (error) {
    console.error('‚ùå FREE AI Bot error:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ 
        error: 'AI Bot processing failed',
        message: error.message
      })
    };
  }
};
